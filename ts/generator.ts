// if(typeof assert_eq !== 'function') {
function assert_eq(a: any, b: any, message: string) {
    if(a !== b) {
        throw new Error(`Assertion Failed: ${message}. Expected "${a}", but got "${b}"`);
    }
}

/**
 * @name Fibonacci
 * @description k-th Fibonacci Word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to ab, b \to a \} \) on the letter 'b'
 * @wikipedia Fibonacci_word
 * @oeis A003849
 */
function generate_fibonacci_word(k : number) : string {
	if(k == 0) return "b";
        const prev = generate_fibonacci_word(k - 1);
        return [...prev].map(c => (c == 'a') ? 'ab' : 'a').join('');
}

export function test_fibonacci_word() {
    assert_eq(generate_fibonacci_word(0), "b", "Fibonacci Word 0");
    assert_eq(generate_fibonacci_word(1), "a", "Fibonacci Word 1");
    assert_eq(generate_fibonacci_word(2), "ab", "Fibonacci Word 2");
    assert_eq(generate_fibonacci_word(3), "aba", "Fibonacci Word 3");
    assert_eq(generate_fibonacci_word(4), "abaab", "Fibonacci Word 4");
    assert_eq(generate_fibonacci_word(5), "abaababa", "Fibonacci Word 5");
    assert_eq(generate_fibonacci_word(6), "abaababaabaab", "Fibonacci Word 6");
}

/**
 * @name Tribonacci
 * @description k-th Tribonacci Word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to ab, b \to ac, c \to a \} \) on the letter 'a'
 * @oeis A080843
 * @wikipedia Tribonacci_word
 */
function generate_tribonacci_word(k : number) : string {
    if(k == 0) return "a";
    const prev = generate_tribonacci_word(k - 1);
    return [...prev].map(c => {
        if(c == 'a') return 'ab';
        if(c == 'b') return 'ac';
        return 'a';
    }).join('');
}

/**
 * @name Thue-Morse
 * @description k-th Thue-Morse Word
 * @reference https://en.wikipedia.org/wiki/Thue%E2%80%93Morse_sequence
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to ab, b \to ba \} \) on the letter 'a'
 * @oeis A010060
 * @wikipedia Thue-Morse_sequence
 */
function generate_thue_morse_word(k : number) : string {
    if(k == 0) return "a";
    const prev = generate_thue_morse_word(k - 1);
    return prev + [...prev].map(c => (c == 'a') ? 'b' : 'a').join('');
}

export function test_thue_morse_word() {
    assert_eq(generate_thue_morse_word(0), "a", "Thue-Morse Word 0");
    assert_eq(generate_thue_morse_word(1), "ab", "Thue-Morse Word 1");
    assert_eq(generate_thue_morse_word(2), "abba", "Thue-Morse Word 2");
    assert_eq(generate_thue_morse_word(3), "abbabaab", "Thue-Morse Word 3");
    assert_eq(generate_thue_morse_word(4), "abbabaabbaababba", "Thue-Morse Word 4");
}

/**
 * @name Mephisto-Waltz
 * @description k-th Mephisto-Waltz Word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to aab, b \to bba \} \) on the letter 'a'
 * @oeis A064990
 * @cite allouche03automatic
 */
function generate_mephisto_waltz_word(k : number) : string {
    if(k == 0) return "a";
    const prev = generate_mephisto_waltz_word(k - 1);
    return [...prev].map(char => (char == 'a') ? 'aab' : 'bba').join('');
}

export function test_mephisto_waltz_word() {
    assert_eq(generate_mephisto_waltz_word(0), "a", "Mephisto-Waltz Word 0");
    assert_eq(generate_mephisto_waltz_word(1), "aab", "Mephisto-Waltz Word 1");
    assert_eq(generate_mephisto_waltz_word(2), "aabaabbbba", "Mephisto-Waltz Word 2");
    assert_eq(generate_mephisto_waltz_word(3), "aabaabbbbaaabaabbbbaaaabbbba", "Mephisto-Waltz Word 3");
}


/**
 * @name vtm
 * @description variant ternary squarefree Thueâ€“Morse word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to abc, b \to ac, c \to b \} \) on the letter 'a'
 * @oeis: A036580
 *
 */
function generate_vtm_word(k : number) : string {
    if(k == 0) return "a";
    const prev = generate_vtm_word(k - 1);
    return [...prev].map((c) => {
        if(c == 'a') return 'abc';
        if(c == 'b') return 'ac';
        return 'b';
    }).join('');
}
export function test_vtm_word() {
    assert_eq(generate_vtm_word(0), "a", "vtm Word 0");
    assert_eq(generate_vtm_word(1), "abc", "vtm Word 1");
    assert_eq(generate_vtm_word(2), "abcacb", "vtm Word 2");
    assert_eq(generate_vtm_word(3), "abcacbabcbabc", "vtm Word 3");
}

/**
 * @name Sierpinski
 * @description Sierpinski Word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to aba, b \to bbb \} \) on the letter 'a'
 * @oeis A316829
 */
function generate_sierpinski_word(k : number) : string {
    if(k == 0) return "a";
    const prev = generate_sierpinski_word(k - 1);
    return [...prev].map(c => (c == 'a') ? 'aba' : 'bbb').join('');
}

export function test_sierpinski_word() {
    assert_eq(generate_sierpinski_word(0), "a", "Sierpinski Word 0");
    assert_eq(generate_sierpinski_word(1), "aba", "Sierpinski Word 1");
    assert_eq(generate_sierpinski_word(2), "ababbbaaba", "Sierpinski Word 2");
    assert_eq(generate_sierpinski_word(3), "ababbbaababbbbabbbababbbaaba", "Sierpinski Word 3");
}

/**
 * @name Pell
 * @description k-th Pell Word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to aab, b \to a \} \) on the letter 'a'
 * @oeis A171588
 */
function generate_pell_word(k : number) : string {
    if(k == 0) return "a";
    const prev = generate_pell_word(k - 1);
    return [...prev].map(c => (c == 'a') ? 'aab' : 'a').join('');
}
export function test_pell_word() {
    assert_eq(generate_pell_word(0), "a", "Pell Word 0");
    assert_eq(generate_pell_word(1), "aab", "Pell Word 1");
    assert_eq(generate_pell_word(2), "aabaabaa", "Pell Word 2");
    assert_eq(generate_pell_word(3), "aabaabaaaabaabaaab", "Pell Word 3");
}

/**
 * @name Chacon
 * @description k-th Chacon Word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to aaba, b \to b \} \) on the letter 'a'
 * @oeis A049320
 */
function generate_chacon_word(k : number) : string {
    if(k == 0) return "a";
    const prev = generate_chacon_word(k - 1);
    return [...prev].map(c => (c == 'a') ? 'aaba' : 'b').join('');
}
export function test_chacon_word() {
    assert_eq(generate_chacon_word(0), "a", "Chacon Word 0");
    assert_eq(generate_chacon_word(1), "aaba", "Chacon Word 1");
    assert_eq(generate_chacon_word(2), "aabaaabaabaa", "Chacon Word 2");
    assert_eq(generate_chacon_word(3), "aabaaabaabaaaabaaabaabaaaabaa", "Chacon Word 3");
}

/**
 * @name Neumannn
 * @description von Neumann Word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to aab, b \to b \} \) on the letter 'a'
 * @oeis A308187
 */
function generate_von_neumann_word(k : number) : string {
    if(k == 0) return "a";
    const prev = generate_von_neumann_word(k - 1);
    return [...prev].map(c => (c == 'a') ? 'aab' : 'b').join('');
}
export function test_von_neumann_word() {
    assert_eq(generate_von_neumann_word(0), "a", "von Neumann Word 0");
    assert_eq(generate_von_neumann_word(1), "aab", "von Neumann Word 1");
    assert_eq(generate_von_neumann_word(2), "aabaabaa", "von Neumann Word 2");
    assert_eq(generate_von_neumann_word(3), "aabaabaaaabaabaaab", "von Neumann Word 3");
}

function rudin_shapiro_preword(k : number) : string {
    if(k == 0) return "a";
    const prev = rudin_shapiro_preword(k - 1);
    return [...prev].map(c => {
        if(c == 'a') return 'ab';
        if(c == 'b') return 'ac';
        if(c == 'c') return 'db';
        return 'dc';
    }).join('');
}

/**
 * @name Rudin-Shapiro
 * @description k-th Rudin-Shapiro Word
 * @tutorial Morphic word generated by the morphism \( \{ a \to ab, b \to ac, c \to db, d \to dc \} \) followed by the coding \( \{ a,b \to a; c,d \to b \} \) on the letter 'a'
 * @oeis A020987
 */
function generate_rudin_shapiro_word(k : number) : string {
    if(k == 0) return "a";
    const prev = rudin_shapiro_preword(k);
    return [...prev].map(c => (c == 'a' || c == 'b') ? 'a' : 'b').join('');
}

/**
 * @name Baum-Sweet
 * @description k-th Baum-Sweet Word
 * @tutorial Word defined by setting the \(j\)-th letter to 'b' if the binary representation of \(j\) contains no block of consecutive 0s of odd length, and to 'a' otherwise.
 * @oeis A086747
 */
function generate_baum_sweet_word(k : number) : string {
    const length = Math.pow(2, k);
    let result = "";
    for(let n = 0; n < length; n++) {
        const binary = n.toString(2);
        let has_odd_zero_block = false;
        let zero_count = 0;
        for(let char of binary) {
            if(char == '0') {
                zero_count++;
            } else {
                if(zero_count % 2 == 1) {
                    has_odd_zero_block = true;
                    break;
                }
                zero_count = 0;
            }
        }
        if(zero_count % 2 == 1) {
            has_odd_zero_block = true;
        }
        result += has_odd_zero_block ? 'a' : 'b';
    }
    return result;
}
export function test_baum_sweet_word() {
    assert_eq(generate_baum_sweet_word(0), "b", "Baum-Sweet Word 0");
    assert_eq(generate_baum_sweet_word(1), "ba", "Baum-Sweet Word 1");
    assert_eq(generate_baum_sweet_word(2), "babb", "Baum-Sweet Word 2");
    assert_eq(generate_baum_sweet_word(3), "babbaaaa", "Baum-Sweet Word 3");
}

/**
 * @name Kolakoski
 * @description k-th Kolakoski Word
 * @tutorial Self-generating word over the alphabet {a,b} where 'a' represents 1 and 'b' represents 2. The word starts with "ab" and the lengths of consecutive runs are given by the word itself.
 * @oeis A000002
 */
function generate_kolakoski_word(k : number) : string {
    if(k == 0) return "ab";
    const prev = generate_kolakoski_word(k - 1);
    let result = "";
    for(let i = 0; i < prev.length; ++i) {
        if(i % 2 == 0) {
            result += (prev[i] == 'a') ? 'a' : 'aa';
        } else {
            result += (prev[i] == 'a') ? 'b' : 'bb';
        }
    }
    return result;
}
export function test_kolakoski_word() {
    assert_eq(generate_kolakoski_word(0), "ab", "Kolakoski Word 0");
    assert_eq(generate_kolakoski_word(1), "abb", "Kolakoski Word 1");
    assert_eq(generate_kolakoski_word(2), "abbaab", "Kolakoski Word 2");
    assert_eq(generate_kolakoski_word(3), "abbaababbaabb", "Kolakoski Word 3");
}
