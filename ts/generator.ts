// if(typeof assert_eq !== 'function') {
function assert_eq(a: any, b: any, message: string) {
    let equal = false;
    if (Array.isArray(a) && Array.isArray(b)) {
        equal = a.length === b.length && a.every((v, i) => v === b[i]);
    } else {
        equal = a === b;
    }
    
    if (!equal) {
        const aStr = Array.isArray(a) ? `[${a}]` : a;
        const bStr = Array.isArray(b) ? `[${b}]` : b;
        throw new Error(`Assertion Failed: ${message}. Expected "${bStr}", but got "${aStr}"`);
    }

}

/**
 * @name Fibonacci
 * @description k-th Fibonacci Word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to ab, b \to a \} \) on the letter 'b'
 * @wikipedia Fibonacci_word
 * @oeis A003849
 */
function generate_fibonacci_word(k : number) : string {
    if(k <= 0) return "b";
    const prev = generate_fibonacci_word(k - 1);
    return [...prev].map(c => (c == 'a') ? 'ab' : 'a').join('');
}

export function test_fibonacci_word() {
    assert_eq(generate_fibonacci_word(0), "b", "Fibonacci Word 0");
    assert_eq(generate_fibonacci_word(1), "a", "Fibonacci Word 1");
    assert_eq(generate_fibonacci_word(2), "ab", "Fibonacci Word 2");
    assert_eq(generate_fibonacci_word(3), "aba", "Fibonacci Word 3");
    assert_eq(generate_fibonacci_word(4), "abaab", "Fibonacci Word 4");
    assert_eq(generate_fibonacci_word(5), "abaababa", "Fibonacci Word 5");
    assert_eq(generate_fibonacci_word(6), "abaababaabaab", "Fibonacci Word 6");
}

/**
 * @name Tribonacci
 * @description k-th Tribonacci Word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to ab, b \to ac, c \to a \} \) on the letter 'a'
 * @oeis A080843
 * @wikipedia Tribonacci_word
 */
function generate_tribonacci_word(k : number) : string {
    if(k <= 0) return "a";
    const prev = generate_tribonacci_word(k - 1);
    return [...prev].map(c => {
        if(c == 'a') return 'ab';
        if(c == 'b') return 'ac';
        return 'a';
    }).join('');
}
export function test_tribonacci_word() {
    assert_eq(generate_tribonacci_word(0), "a", "Tribonacci Word 0");
    assert_eq(generate_tribonacci_word(1), "ab", "Tribonacci Word 1");
    assert_eq(generate_tribonacci_word(2), "abac", "Tribonacci Word 2");
    assert_eq(generate_tribonacci_word(3), "abacaba", "Tribonacci Word 3");
    assert_eq(generate_tribonacci_word(4), "abacabaabacab", "Tribonacci Word 4");
    assert_eq(generate_tribonacci_word(5), "abacabaabacababacabaabac", "Tribonacci Word 5");
    assert_eq(generate_tribonacci_word(6), "abacabaabacababacabaabacabacabaabacababacaba", "Tribonacci Word 6");



}

/**
 * @name Thue-Morse
 * @description k-th Thue-Morse Word
 * @reference https://en.wikipedia.org/wiki/Thue%E2%80%93Morse_sequence
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to ab, b \to ba \} \) on the letter 'a'
 * @oeis A010060
 * @wikipedia Thue-Morse_sequence
 */
function generate_thue_morse_word(k : number) : string {
    if(k <= 0) return "a";
    const prev = generate_thue_morse_word(k - 1);
    return prev + [...prev].map(c => (c == 'a') ? 'b' : 'a').join('');
}

export function test_thue_morse_word() {
    assert_eq(generate_thue_morse_word(0), "a", "Thue-Morse Word 0");
    assert_eq(generate_thue_morse_word(1), "ab", "Thue-Morse Word 1");
    assert_eq(generate_thue_morse_word(2), "abba", "Thue-Morse Word 2");
    assert_eq(generate_thue_morse_word(3), "abbabaab", "Thue-Morse Word 3");
    assert_eq(generate_thue_morse_word(4), "abbabaabbaababba", "Thue-Morse Word 4");
}

/**
 * @name Mephisto-Waltz
 * @description k-th Mephisto-Waltz Word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to aab, b \to bba \} \) on the letter 'a'
 * @oeis A064990
 * @cite allouche03automatic
 */
function generate_mephisto_waltz_word(k : number) : string {
    if(k <= 0) return "a";
    const prev = generate_mephisto_waltz_word(k - 1);
    return [...prev].map(char => (char == 'a') ? 'aab' : 'bba').join('');
}

export function test_mephisto_waltz_word() {
    assert_eq(generate_mephisto_waltz_word(0), "a", "Mephisto-Waltz Word 0");
    assert_eq(generate_mephisto_waltz_word(1), "aab", "Mephisto-Waltz Word 1");
    assert_eq(generate_mephisto_waltz_word(2), "aabaabbba", "Mephisto-Waltz Word 2");
    assert_eq(generate_mephisto_waltz_word(3), "aabaabbbaaabaabbbabbabbaaab", "Mephisto-Waltz Word 3");
    assert_eq(generate_mephisto_waltz_word(4), "aabaabbbaaabaabbbabbabbaaabaabaabbbaaabaabbbabbabbaaabbbabbaaabbbabbaaabaabaabbba", "Mephisto-Waltz Word 4");
}


/**
 * @name vtm
 * @description variant ternary squarefree Thueâ€“Morse word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to abc, b \to ac, c \to b \} \) on the letter 'a'
 * @oeis: A036580
 *
 */
function generate_vtm_word(k : number) : string {
    if(k <= 0) return "a";
    const prev = generate_vtm_word(k - 1);
    return [...prev].map((c) => {
        if(c == 'a') return 'abc';
        if(c == 'b') return 'ac';
        return 'b';
    }).join('');
}
export function test_vtm_word() {
    assert_eq(generate_vtm_word(0), "a", "vtm Word 0");
    assert_eq(generate_vtm_word(1), "abc", "vtm Word 1");
    assert_eq(generate_vtm_word(2), "abcacb", "vtm Word 2");
    assert_eq(generate_vtm_word(3), "abcacbabcbac", "vtm Word 2");
    assert_eq(generate_vtm_word(4), "abcacbabcbacabcacbacabcb", "vtm Word 3");
    assert_eq(generate_vtm_word(5), "abcacbabcbacabcacbacabcbabcacbabcbacabcbabcacbac", "vtm Word 4");
}

/**
 * @name Sierpinski
 * @description Sierpinski Word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to aba, b \to bbb \} \) on the letter 'a'
 * @oeis A316829
 */
function generate_sierpinski_word(k : number) : string {
    if(k <= 0) return "a";
    const prev = generate_sierpinski_word(k - 1);
    return [...prev].map(c => (c == 'a') ? 'aba' : 'bbb').join('');
}

export function test_sierpinski_word() {
    assert_eq(generate_sierpinski_word(0), "a", "Sierpinski Word 0");
    assert_eq(generate_sierpinski_word(1), "aba", "Sierpinski Word 1");
    assert_eq(generate_sierpinski_word(2), "ababbbaba", "Sierpinski Word 2");
    assert_eq(generate_sierpinski_word(3), "ababbbababbbbbbbbbababbbaba", "Sierpinski Word 3");
    assert_eq(generate_sierpinski_word(4), "ababbbababbbbbbbbbababbbababbbbbbbbbbbbbbbbbbbbbbbbbbbababbbababbbbbbbbbababbbaba", "Sierpinski Word 4");
}

/**
 * @name Pell
 * @description k-th Pell Word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to aab, b \to a \} \) on the letter 'a'
 * @oeis A171588
 */
function generate_pell_word(k : number) : string {
    if(k <= 0) return "a";
    const prev = generate_pell_word(k - 1);
    return [...prev].map(c => (c == 'a') ? 'aab' : 'a').join('');
}
export function test_pell_word() {
    assert_eq(generate_pell_word(0), "a", "Pell Word 0");
    assert_eq(generate_pell_word(1), "aab", "Pell Word 1");
    assert_eq(generate_pell_word(2), "aabaaba", "Pell Word 2");
    assert_eq(generate_pell_word(3), "aabaabaaabaabaaab", "Pell Word 3");
    assert_eq(generate_pell_word(4), "aabaabaaabaabaaabaabaabaaabaabaaabaabaaba", "Pell Word 4");
}

/**
 * @name Chacon
 * @description k-th Chacon Word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to aaba, b \to b \} \) on the letter 'a'
 * @oeis A049320
 */
function generate_chacon_word(k : number) : string {
    if(k <= 0) return "a";
    const prev = generate_chacon_word(k - 1);
    return [...prev].map(c => (c == 'a') ? 'aaba' : 'b').join('');
}
export function test_chacon_word() {
    assert_eq(generate_chacon_word(0), "a", "Chacon Word 0");
    assert_eq(generate_chacon_word(1), "aaba", "Chacon Word 1");
    assert_eq(generate_chacon_word(2), "aabaaababaaba", "Chacon Word 2");
    assert_eq(generate_chacon_word(3), "aabaaababaabaaabaaababaababaabaaababaaba", "Chacon Word 3");
}

/**
 * @name Neumannn
 * @description von Neumann Word
 * @tutorial Pure morphic word generated by the morphism \( \{ a \to aab, b \to b \} \) on the letter 'a'
 * @oeis A308187
 */
function generate_von_neumann_word(k : number) : string {
    if(k <= 0) return "a";
    const prev = generate_von_neumann_word(k - 1);
    return [...prev].map(c => (c == 'a') ? 'aab' : 'b').join('');
}
export function test_von_neumann_word() {
    assert_eq(generate_von_neumann_word(0), "a", "von Neumann Word 0");
    assert_eq(generate_von_neumann_word(1), "aab", "von Neumann Word 1");
    assert_eq(generate_von_neumann_word(2), "aabaabb", "von Neumann Word 2");
    assert_eq(generate_von_neumann_word(3), "aabaabbaabaabbb", "von Neumann Word 3");
    assert_eq(generate_von_neumann_word(4), "aabaabbaabaabbbaabaabbaabaabbbb", "von Neumann Word 4");
    assert_eq(generate_von_neumann_word(5), "aabaabbaabaabbbaabaabbaabaabbbbaabaabbaabaabbbaabaabbaabaabbbbb", "von Neumann Word 5");
}

function rudin_shapiro_preword(k : number) : string {
    if(k <= 0) return "a";
    const prev = rudin_shapiro_preword(k - 1);
    return [...prev].map(c => {
        if(c == 'a') return 'ab';
        if(c == 'b') return 'ac';
        if(c == 'c') return 'db';
        return 'dc';
    }).join('');
}

/**
 * @name Rudin-Shapiro
 * @description k-th Rudin-Shapiro Word
 * @tutorial Morphic word generated by the morphism \( \{ a \to ab, b \to ac, c \to db, d \to dc \} \) followed by the coding \( \{ a,b \to a; c,d \to b \} \) on the letter 'a'
 * @oeis A020987
 */
function generate_rudin_shapiro_word(k : number) : string {
    if(k <= 0) return "a";
    const prev = rudin_shapiro_preword(k);
    return [...prev].map(c => (c == 'a' || c == 'b') ? 'a' : 'b').join('');
}

export function test_rudin_shapiro_word() {
    assert_eq(generate_rudin_shapiro_word(0), "a", "Rudin-Shapiro Word 0");
    assert_eq(generate_rudin_shapiro_word(1), "aa", "Rudin-Shapiro Word 1");
    assert_eq(generate_rudin_shapiro_word(2), "aaab", "Rudin-Shapiro Word 2");
    assert_eq(generate_rudin_shapiro_word(3), "aaabaaba", "Rudin-Shapiro Word 3");
    assert_eq(generate_rudin_shapiro_word(4), "aaabaabaaaabbbab", "Rudin-Shapiro Word 4");
    assert_eq(generate_rudin_shapiro_word(5), "aaabaabaaaabbbabaaabaababbbaaaba", "Rudin-Shapiro Word 5");
}

function baum_sweet_preword(k : number) : string {
    if(k <= 0) return "a";
    const prev = baum_sweet_preword(k - 1);
    return [...prev].map(c => {
        if(c == 'a') return 'ab';
        if(c == 'b') return 'cb';
        if(c == 'c') return 'bd';
        return 'dd';
    }).join('');
}

/**
 * @name Baum-Sweet
 * @description k-th Baum-Sweet Word
 * @tutorial Word defined by setting the \(j\)-th letter to 'b' if the binary representation of \(j\) contains no block of consecutive 0s of odd length, and to 'a' otherwise.
 * @oeis A086747
 */
function generate_baum_sweet_word(k : number) : string {
    if(k <= 0) return "a";
    // Alternatively, we can generate it using morphism and coding:
    const prev = baum_sweet_preword(k);
    return [...prev].map(c => (c == 'c' || c == 'd') ? 'a' : c).join('');
}
export function test_baum_sweet_word() {
    assert_eq(generate_baum_sweet_word(0), "a", "Baum-Sweet Word 0");
    assert_eq(generate_baum_sweet_word(1), "ab", "Baum-Sweet Word 1");
    assert_eq(generate_baum_sweet_word(2), "abab", "Baum-Sweet Word 2");
    assert_eq(generate_baum_sweet_word(3), "ababbaab", "Baum-Sweet Word 3");
    assert_eq(generate_baum_sweet_word(4), "ababbaababaabaab", "Baum-Sweet Word 4");
}

/**
 * @name Kolakoski
 * @description k-th Kolakoski Word
 * @tutorial Self-generating word over the alphabet {a,b} where 'a' represents 1 and 'b' represents 2. The word starts with "ab" and the lengths of consecutive runs are given by the word itself.
 * @oeis A000002
 */
function generate_kolakoski_word(k : number) : string {
    if(k <= 0) return "ab";
    const prev = generate_kolakoski_word(k - 1);
    let result = "";
    for(let i = 0; i < prev.length; ++i) {
        if(i % 2 == 0) {
            result += (prev[i] == 'a') ? 'a' : 'aa';
        } else {
            result += (prev[i] == 'a') ? 'b' : 'bb';
        }
    }
    return result;
}
export function test_kolakoski_word() {
    assert_eq(generate_kolakoski_word(0), "ab", "Kolakoski Word 0");
    assert_eq(generate_kolakoski_word(1), "abb", "Kolakoski Word 1");
    assert_eq(generate_kolakoski_word(2), "abbaa", "Kolakoski Word 2");
    assert_eq(generate_kolakoski_word(3), "abbaaba", "Kolakoski Word 3");
    assert_eq(generate_kolakoski_word(4), "abbaababba", "Kolakoski Word 4");
}
